# 💻 JVM(Java Virtual Machine)

OS에 종속받지 않고 CPU가 Java를 인식, 실행할 수 있게 하는 가상 컴퓨터

Java는 JVM을 거쳐서 OS에 도달하기 때문에, JVM이 인식할 수 있는 bytecode(\*.class)로 변환

## 🧩 JVM 구성 요소

### 1. 클래스 로더

클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크하는 역할

런타임시 동적으로 클래스를 로드하고 jar 파일 내 저장된 클래스들을 JVM 위에 탑재한다.

### 2. 실행 엔진

클래스 로더가 JVM 내의 런타임 데이터 영역에 바이트 코드를 배치시키면, 이것은 실행 엔진에 의해 실행

- 인터프리터

  바이트 코드를 명령어 단위로 읽어서 실행하며, 한 줄씩 수행해서 느리다.

- JIT 컴파일러

  인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일하여 기계어로 변경하고, 이후에는 더이상 인터프리팅 하지 않고 기계어로 직접 실행하는 방식이다.

- 가비지 콜렉터

  더이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제한다.

### 3. 런타임 데이터 영역

프로그램을 수행하기 위해 OS에서 할당 받은 메모리 공간

- **PC Register**
  - Thread가 시작될 때 생성되며, 생성될 때마다 생성되는 공간으로, Thread마다 하나씩 존재한다.
  - Thread가 어떤 부분을 어떤 명령으로 실행할 지에 대한 기록을 하는 부분으로 현재 수행 중인 JVM 명령의 주소를 갖는다.
- **JVM Stack**
  - 프로그램 실행 과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다.
  - 호출된 메소드의 매개변수, 지역변수, 리턴 값 및 연산시 일어나는 값 등을 임시로 저장한다.
  - 메소드 호출 시마다 각각의 스택 프레임(해당 메소드를 위한 공간)이 생성되고, 메소드 수행이 끝나면 프레임 별로 삭제한다.
- **Native Method Stack**
  - 자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역
  - Java가 아닌 다른 언어(C, C++ ..)로 작성된 코드를 위한 공간
- **Method Area (class/static)**

  클래스 정보를 처음 메모리 공간에 올릴 때, 초기화 되는 대상을 저장하기 위한 메모리 공간

  - Runtime Constant Pool

    Static 영역에 존재하는 별도의 관리 영역

    상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행한다.

    static 영역에 저장되는 데이터(멤버 변수, 메소드, 타입)

- **Heap Area**

  객체를 저장하는 가상 메모리 공간으로, new 연산자로 생성되는 객체와 배열을 저장한다.

  Class Area(Static Area)에 올라온 클래스들만 객체로 생성할 수 있다.

  - Permanent Generation

    생성된 객체들의 정보의 주소값이 저장된 공간이다.

    클래스 로더에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고, JVM에 의해 사용된다.

  - New/Young 영역

    이 영역의 인스턴스들은 추후 가비지 콜렉터에 의해 사라진다.

    생명 주기가 짧은 "젊은 객체"를 GC 대상으로 하는 영역이다.

    여기서 일어나는 가비지 콜렉트를 `Minor GC` 라고 한다.

  - Old 영역

    이 영역의 인스턴스들은 추후 가비지 콜렉터에 의해 사라진다.

    생명 주기가 긴 "오래된 객체"를 GC 대상으로 하는 영역이다.

    여기서 일어나는 가비지 콜렉트를 `Major GC` 라고 한다.

    New/Young 영역에서 일정 시간 참조되고 있는, 살아남은 객체들이 저장되는 공간이다.
